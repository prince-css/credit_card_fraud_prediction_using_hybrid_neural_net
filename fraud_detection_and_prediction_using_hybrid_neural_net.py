# -*- coding: utf-8 -*-
"""fraud_detection_and_prediction_using_hybrid_neural_net.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hun7KztH3w7phg4nFofjTiVlYbCqh6FJ

SOM IS AN UNSUPERVISED DEEP LEARNING MODEL

Dataset: https://archive.ics.uci.edu/ml/datasets/statlog+(australian+credit+approval)

This file concerns credit card applications. All attribute names and values have been changed to meaningless symbols to protect confidentiality of the data.

This dataset is interesting because there is a good mix of attributes -- continuous, nominal with small numbers of values, and nominal with larger numbers of values. There are also a few missing values.

There are 6 numerical and 8 categorical attributes. The labels have been changed for the convenience of the statistical algorithms. For example, attribute 4 originally had 3 labels p,g,gg and these have been changed to labels 1,2,3.

A1: 0,1 CATEGORICAL (formerly: a,b)

A2: continuous.

A3: continuous.

A4: 1,2,3 CATEGORICAL (formerly: p,g,gg)

A5: 1, 2,3,4,5, 6,7,8,9,10,11,12,13,14 CATEGORICAL (formerly: ff,d,i,k,j,aa,m,c,w, e, q, r,cc, x)

A6: 1, 2,3, 4,5,6,7,8,9 CATEGORICAL (formerly: ff,dd,j,bb,v,n,o,h,z)

A7: continuous.

A8: 1, 0 CATEGORICAL (formerly: t, f)

A9: 1, 0 CATEGORICAL (formerly: t, f)

A10: continuous.

A11: 1, 0 CATEGORICAL (formerly t, f)

A12: 1, 2, 3 CATEGORICAL (formerly: s, g, p)

A13: continuous.

A14: continuous.

A15/class: 1,2 class attribute (formerly: +,-) or (1: Approved or 0: Not Approved)
"""

!pip install MiniSom

"""Importing MiniSom library"""

from minisom import MiniSom

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

dataset=pd.read_csv("Credit_Card_Applications.csv")
dataset.describe()

X=dataset.iloc[:,0:-1].values
Y=dataset.iloc[:,-1].values

"""Data Normalization"""

from sklearn.preprocessing import MinMaxScaler
scaler=MinMaxScaler(feature_range=(0,1))
X_scaled=scaler.fit_transform(X)

print(X)

print(X_scaled)

"""SOM initializaton and training"""

n_neuron=10
m_neuron=10
# input_len=number of features or, number of columuns(excluding target)
som=MiniSom(n_neuron, m_neuron, input_len=X_scaled.shape[1], sigma=1, 
            learning_rate=0.5, neighborhood_function='gaussian')
som.random_weights_init(X_scaled)
som.train(X_scaled, 100)

distances=som.distance_map()
#win_map diye kono ekta winning node kon kon sample er jonne hoiche seta bujhaay
mappings=som.win_map(X_scaled,return_indices=True)
#mappings holo ekta dictionary type er container
count=0
for i in mappings:
    print("for coordinate no. ", i)
    print("It is the winning node for sample no. :")
    for j in mappings.get(i):
        print(j)
        count=count+1
print(mappings)
print(count)

"""Visualization

"""

# Commented out IPython magic to ensure Python compatibility.
#originally:
#red= 0 means NOT Approved by the bank
#green= 1 means Approved by the bank

#in color graph:
#white=fraud cluster
#black=good cluster
# %matplotlib inline
plt.figure(figsize=(10,10))
plt.pcolor(som.distance_map().T, cmap='bone')
plt.colorbar()

markers=['o','*']
colors=['r','g']
for i, xx in enumerate(X_scaled):
    w=som.winner(xx)
    plt.plot(w[0]+0.5,w[1]+0.5,markers[Y[i]],markerfacecolor='None',
             markeredgecolor=colors[Y[i]],markersize=15,markeredgewidth=2)
plt.show()

#decision:
#black+red--> Bank did NOT approve a good people
#black+green-->Bank approved a good people
#white+green--> Bank approved a FRAUD people
#white+red--> Bank did not approve a FRAUD people

"""Detecting obvious frauds"""

#at that time coordinates (1,6),(1,7),(1,8) were more white-ish, so they are the obvious frauds
frauds=np.concatenate((mappings.get((7,7)),mappings.get((8,7)),mappings.get((6,6)), mappings.get((6,7))),axis=0)
for i in frauds:
    print(int(X[i,0]))

"""Predicting the probability for being fraud of any customer using SUPERVISED Deep Lesarning Model"""

#input feature matrix
X_train=dataset.iloc[:,1:].values
scaler2=MinMaxScaler()
X_train=scaler2.fit_transform(X_train)
Y_train=np.zeros(len(X))
#generating output depended variable
for cnt, i in enumerate(X):
    for j in frauds:
        #print(cnt," ohho ", j)
        if int(cnt)==int(j):
            Y_train[cnt]=1
            break
        else:
            Y_train[cnt]=0

np.shape(X_train)

print(len(Y_train))
print(Y_train)

"""Building ANN model"""

import tensorflow as tf

model=tf.keras.Sequential()
model.add(tf.keras.layers.Dense(8, activation='relu', input_shape=(15,)))
model.add(tf.keras.layers.Dense(32,activation='relu'))
model.add(tf.keras.layers.Dense(64,activation='relu'))
model.add(tf.keras.layers.Dense(1,activation='sigmoid'))
model.compile(optimizer='adam', loss= tf.keras.losses.BinaryCrossentropy(),metrics=['accuracy'])
model.fit(x=X_train, y=Y_train, batch_size=1, epochs=5)
model.evaluate(x=X_train, y=Y_train, batch_size=1)



from sklearn.metrics import accuracy_score 
Y_predict=model.predict(X_train)
#print(Y_predict)

"""Ranking the customers according to their fraud probability """

Y_predict=np.concatenate((X[:,0:1],Y_predict[:,0:1]),axis=1)

print(Y_predict)

Y_predict=Y_predict[Y_predict[:,1].argsort()]

print(Y_predict)